---
title: "Tidyverse programming tutorial"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gapminder)
```

## ♥ Tidyverse = super easy to work with! ♥

Let's suppose we want to calculate the mean life expectancy per
continent per year for the Gapminder dataset:

```{r contrived_example}
# Quickly calculate grouepd means
meanLE_year <- gapminder %>% 
  group_by(year) %>% 
  summarise(meanLE = mean(lifeExp, na.rm = T))

meanLE_continent <- gapminder %>% 
  group_by(continent) %>% 
  summarise(meanLE = mean(lifeExp, na.rm = T))

meanLE_country <- gapminder %>% 
  group_by(country) %>% 
  summarise(meanLE = mean(lifeExp, na.rm = T))

# Quickly plot the output
ggplot(meanLE_year, aes(x = year, y = meanLE)) + geom_point() + geom_smooth(method = "lm")

ggplot(meanLE_continent, aes(x = continent, y = meanLE)) + geom_point() 

ggplot(meanLE_country, aes(x = country, y = meanLE)) + geom_point() 

```

Simple - right!?

Once we specify the dataset we are working with we can directly type the
names of the columns and variables in the dataset we wish without have
to enclose them in quotation marks or having to define them relative to
the dataset itself.

## But there's a problem! Trouble in paradise?

In the example above we calculated the same metric for three different
grouping variables by repeating the code and changing one element. This
is not good coding practice. When we find ourselves repeating code we
should look at using some kind of iteration tool or writing a bespoke
function.

Also, might want to get and plot the means of population size and
gdpPercap as well as lifeExp across continents and years. Or we might
want to get means by countries and years. We can't (shouldn't!) repeat
the above code that many times! We need to write re-usable code.

SOOOO..... what happens if we want to try to turn the above code into a
function or use it in a loop?

```{r try_function, error=TRUE}
# Place code within function

gap_mean <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by(grouping_variable) %>% 
  summarise(mean = mean(summary_column, na.rm = T))
}

#Does it work?
gap_mean(gapminder, year, lifeExp)

#What about if we place the arguments in quotes?
gap_mean(gapminder, "year", "lifeExp")

#Another example - What if tried to build a generic plotting function for all of the above dataset?
plot_fun <- function(data, x, y){
  data %>% 
  ggplot(aes(x = x, y = y)) +
  geom_point() 
}

plot_fun(meanLE_continent, x = continent, y = meanLE)
plot_fun(meanLE_continent, x = "continent", y = "meanLE")
```

ALSO - a problem if you want to use dplyr functions in loops

```{r try_loop, message=FALSE}
columns <- c("lifeExp", "pop", "gdpPercap")
out <- rep(list(NULL), 3)

for(i in seq_along(columns)){
  out[[i]] <- gapminder %>% 
    summarise(mean = mean(columns[[i]], na.rm = T))
}

out[[1]]
```

------------------------------------------------------------------------

## NSE = Non-standard evaluation (VERY VERY briefly!)

What is NSE? Very roughly, it is to programmatically modify an
expression or its meaning after it is issued but before it is executed.
You can think of an "expression" as an R command you might type at the
prompt or in an R script.

*Not many programming languages give the programmer the power to
implement, use, and abuse Non-Standard Evaluation - but R does!*

And not just in Tidyverse - ALSO in base R.

```{r NSE_baseR}
subset(mtcars, hp > 250) # this works 
                         # subset delays the evalution of hp > 250 before it is run 
                         # changes its meaning/environment so it relates to mtcars 
mtcars[hp > 250, ] # Does this work?
                   # NO! hp is not defined in our environment

#Other base R NSE functions include:
# transform()
# lm()
# with()
# and the old school (for those of us who learnt R way way before the tidyverse!):
# attach()
```

Much more to learn about NSE!! See list of references at end.

#### ≈ Tidy Evaluation (NSE in the Tidyverse; implemented in the rlang package) has two forms:

**Data Masking** - allows you to use data variables as if they were
variables in the environment/ objects in the workspace --\> i.e. lets
you write `my_variable` not `dataset$myvariable`)

-   `arrange()`, `count()`, `filter()`, `group_by()`, `mutate()`, and
    `summarise()`

Data masking makes data manipulation faster because it requires less
typing (cf with base R):

```{r data_masking, results = FALSE}
#Comapre Base R
gapminder[gapminder$continent == "Europe" & gapminder$pop < 1000000, ]

#With Tidyverse
gapminder %>% filter(continent == "Europe", pop < 1000000)
```

**Tidy Selection** - allows you to easily choose variables based on
their position, name, or type (e.g. `starts_with("x")` or `is.numeric`).

-   `across()`, `relocate()`, `rename()`, `select()`, and `pull()`

To determine whether a function argument uses data masking or tidy
selection, look at the documentation: in the arguments list, you'll see
`<data-masking>` or `<tidy-select>`. Let's look at a few now!

```{r}
?dplyr::arrange
```

```{r}
?dplyr::rename
```

> Tidyverse functions are built for interactivity! They make interactive
> data exploration fast and fluid (and fun!)
>
> But they add some new challenges when you attempt to use them
> indirectly such as in a for loop or a function.

------------------------------------------------------------------------

## Data Masking Problems and Solutions

### **Unexpected masking**

The key idea behind data masking is that it blurs the line between the
two different meanings of the word "variable":

-   **env-variables** are "programming" variables that live in an
    environment. They are usually created with `<-`.

-   **data-variables** are "statistical" variables that live in a data
    frame (come from data files or are created by manipulating existing
    variables within the data frame).

```{r unexp_masking}
# Example of Unexpected masking
# An object in your workspace (which you want to use) has the same name as a dataset column
n <- 100
data1 <- data.frame(x = 1)
data2 <- data.frame(x = 1, n = 2)

data1 %>% mutate(y = x / n) %>% pull(y)
data2 %>% mutate(y = x / n) %>% pull(y)

```

> #### SOLUTION - Be explicit in your code
>
> Use the `.data$` or `.env$` pronouns to explicitly associate variables
> to data frames or the global environment:

```{r unexp_mask_soln}

#Specify .data and .end pronouns
data1 %>% mutate(y = .data$x / .env$n) %>% pull(y)
data2 %>% mutate(y = .data$x / .env$n) %>% pull(y)
```

### **Indirection**

Occurs when data-variables can't get through functions/loops because the
function expects an environment variable:

```{r indrection}
# Example of indirection = function we tried to run above - DOESN'T WORK
gap_mean <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by(grouping_variable) %>% 
  summarise(mean = mean(summary_column, na.rm = T))
}

#It doesn't work
gap_mean(gapminder, year, lifeExp)
```

Inside the function `grouping_variable` and `summary_column` are
environment variables. But when you call the function `year` and
`lifeExp` are data variables.

Data-masked code needs to be *delayed* and *transported* to the data
context. Behind the scenes, dplyr verbs achieve this by capturing the
blueprint of your code, and resuming its evaluation inside the data
mask. The example above fails because `group_by()` is capturing the
wrong piece of blueprint.

> #### SOLUTION - use the curly-curly operator '{{ }}'

> The curly-curly `{{ }}` operator allows you to *tunnel* data variable
> through functions. It acts `{{ }}` as a wrapper for lower level
> operators that function to **quote-and-unquote** the expression
> pattern:
>
> `enquo()` - delays the interpretation of code and captures its
> blueprint and `!!` - which modifies those blueprints.

```{r indrection_soln}
gap_mean <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by({{ grouping_variable }}) %>% 
  summarise(mean = mean({{ summary_column }}, na.rm = T))
}

#It works!
gap_mean(gapminder, year, lifeExp)
gap_mean(gapminder, continent, pop)
```

What about with multiple grouping variables?? Use `across()`

```{r indrection_soln_2}
gap_means <- function(data, grouping_variables, summary_columns){
  data %>% 
  group_by(across({{ grouping_variables }})) %>% 
  summarise(across({{ summary_columns }}, ~ mean(., na.rm = T))) 
  # can also write: summarise(across({{ summary_columns }}, list(mean)))
}

# It works!
gap_means(gapminder, c(country, year), c(lifeExp, pop, gdpPercap))

```

### Naming of variables in functions

> #### Solution - use the walrus operator `:=` or `.names = ""` 
>
> `:=` is the "Walrus operator" and enables dynamic naming of variables
> with tidy evaluation - used when there is only variable in the
> function
>
> use `.names = ""` when there are multiple variables

In the above example we most likely want to improve on the automatic
column names that our new mean columns are given:

```{r, name_assignment}
# Use the Walrus operator and syntax similar to the glue package
gap_mean_name <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by({{ grouping_variable }}) %>% 
  summarise("mean_{{ summary_column }}" := mean({{ summary_column }}, na.rm = T))
}

gap_mean_name(gapminder, country, lifeExp)

# Use the .names = "" option
gap_mean_name_multicols <- function(data, grouping_variable, summary_columns) {
  data %>%
    group_by(across({{grouping_variable}})) %>%
     summarise(across({{ summary_columns }},
         ~ mean(., na.rm = TRUE), .names = "mean_{.col}"), .groups = "drop")
}

gap_mean_name_multicols(gapminder, c(continent, year), c(lifeExp, pop, gdpPercap))
```

### Indirection - What if you have string inputs!?

> #### SOLUTION - use data sub-setting explicitly with: `.data[[ var ]]`
>
> When you have a character env-variable and you wish to input this into
> a function, you need to index into the `.data` pronoun with `[[`.
>
> If you want to assign name then use `:=` + `{ }` (***single curly
> brackets***)

```{r indirection_with_strings}
gap_means <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by(.data[[grouping_variable]]) %>% 
  summarise("mean_{summary_column}" := mean(.data[[summary_column]], na.rm = T))
}

#It works!
gap_means(gapminder, "year", "lifeExp")
```

-   Note that `.data` is not a data frame; it's a special construct, a
    pronoun, within the tidyverse that allows you to access the current
    variables either directly, with `.data$x` or indirectly with
    `.data[[var]]` (it represents the subset for the current group).
    Don't expect other functions to work with it.

-   Note also that using this syntax avoids creating new bespoke
    functions that ARE ALSO DATA MASKING functions! This can be good
    when your code will be used by non-R users or in production.

### Alternative - sometimes needed for string inputs loops

> #### SOLUTION - use !!sym
>
> `sym()` creates a symbol (a kind of defused expression) from a string
> (very similar to `base::as.symbol()` which itself an alias for
> `base::as.name()`). The injection operator `!!` doesn't do anything by
> itself and is not a real operator. It tells `summarise()` to do
> something though, because `summarise()` is designed to recognize it.
> What it tells to `summarise()` is to act as if `!!x` was replaced by
> the quoted content of x.

```{r indirection_with_strings_multiplegroupbys}

#see -issues below
```

```{r for_loop_solved}
# This is the solution - need to use rlang::sym
columns <- c("lifeExp", "pop", "gdpPercap")
out <- rep(list(NULL), 3)

for(i in seq_along(columns)){
  out[[i]] <- gapminder %>% 
    summarise("mean_{ columns[[i]] }" := mean(!!sym(columns[[i]]), na.rm = T))
}

unlist(out)

```

For more information see help("sym") and help("!!") and references
listed below.

------------------------------------------------------------------------

## Tidy Selection: Problems and Solutions

Underneath all functions that use tidy selection is the
[tidyselect](https://tidyselect.r-lib.org/) package. It provides a
miniature domain specific language that makes it easy to select columns
by name, position, or type. For example:

-   `select(df, 1)` selects the first column; `select(df, last_col())`
    selects the last column.

-   `select(df, c(a, b, c))` selects columns `a`, `b`, and `c`.

-   `select(df, starts_with("a"))` selects all columns whose name starts
    with "a"; `select(df, ends_with("z"))` selects all columns whose
    name ends with "z".

-   `select(df, where(is.numeric))` selects all numeric columns.

As with data masking, tidy selection makes a common task easier at the
cost of making a less common task harder.

The solutions are similar to those described:

1.  Be explicit - use .`data$` or `.env$` pronouns to avoid selecting by
    a variable name that also exists in your environment

    ```{r}

    ```

2.  Embrace the function input vars using `{{ }}` - when the input is
    not a string input

    ```{r slice_example}
    slice_fun <- function(data, grouping_variable, columns, rows) {
      data %>% 
        group_by({{ grouping_variable }}) %>% 
        select({{ columns }}) %>% 
        slice(rows)
    }
    slice_fun(gapminder, continent, lifeExp:gdpPercap, 1)
    ```

-   When you have an env-variable that is a character vector, you need
    to use `all_of()` or `any_of()` depending on whether you want the
    function to error if a variable is not found.

    ```{r}
    slice_character <- function(data, grouping_variable, columns, row_start, row_end) {
      data %>% 
        group_by({{ grouping_variable }}) %>% 
        select(all_of(columns)) %>% 
        slice(row_start:row_end)
    }
    slice_character(gapminder, year, c("pop", "lifeExp"), 1, 3)
    ```

-   And if you don't want to propagate data masking:

    ```{r}
    slice_character_subset <- function(data, grouping_variable, columns, row_start, row_end) {
      data %>% 
        group_by(.data[[ grouping_variable ]]) %>% 
        select(all_of(columns)) %>% 
        slice(row_start:row_end)
    }
    slice_character_subset(gapminder, "country", c("pop", "lifeExp"), 1, 3)
    ```

## Using tidy evaluation in other {tidyverse} package functions

Finally, we can apply this same logic to other {tidyverse} package
functions (so far we have just focused on {dplyr}), such as {ggplot2}
functions!

```{r}
scatter_plot <- function(data_frame, x_axis, y_axis) {
  ggplot(data_frame, aes(y = {{ y_axis }}, x = {{ x_axis }})) +
    geom_point(alpha = 0.5)
}
```

## References

<https://www.brodieg.com/2020/05/05/on-nse/>

=========================================

```{r}
# THESE ARE PROBLEMS I CAN'T WORK OUT !!


# WITH DATA SUBSETTING - NAMING WORKS FOR MULTIPLE NAMES!!?
means <- function(data, grouping_variable, summary_column){
  data %>%
    group_by(.data[[grouping_variable]]) %>%
    summarise(.data[[summary_column]], mean(.,  na.rm = TRUE), .names = "mean_{.col}", .groups = "drop")
}
gap_means(gapminder, "year", "lifeExp")


# 3.  Data subsetting with multiple group_bys and summarises!! - Works differently
group_names<-c("continent")
summ_names <- c("lifeExp", "pop")

gap_means_multigps <- function(data, grouping_variables, summary_columns){
  data %>%
    group_by(across(all_of(grouping_variables))) %>%
    #summarise_at(vars(summary_columns), mean) # --> THIS WORKS
    #Experimenting below
    summarise(across(starts_with("pop")), mean)
}
gap_means_multigps(gapminder, group_names, summ_names)

gap_means_multigps(gapminder, group_names)

gapminder %>%
  group_by(across(all_of(group_names))) %>%
  #summarise_at(vars(summ_names), mean) # --> THIS WORKS
  #Experimenting below
  summarise(across(starts_with("pop")), mean)
```


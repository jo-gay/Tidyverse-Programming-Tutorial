---
title: "Tidyverse programming tutorial"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gapminder)
```

## ♥ Tidyverse ♥ - super is easy to work with!

Let's suppose we want to calculate the mean life expectancy per
continent per year for the Gapminder dataset:

```{r contrived_example}
meanLE_year <- gapminder %>% 
  group_by(year) %>% 
  summarise(meanLE = mean(lifeExp, na.rm = T))

meanLE_continent <- gapminder %>% 
  group_by(continent) %>% 
  summarise(meanLE = mean(lifeExp, na.rm = T))

meanLE_country <- gapminder %>% 
  group_by(country) %>% 
  summarise(meanLE = mean(lifeExp, na.rm = T))


ggplot(meanLE_year, aes(x = year, y = meanLE)) + geom_point() + geom_smooth(method = "lm")

ggplot(meanLE_continent, aes(x = continent, y = meanLE)) + geom_point() 

ggplot(meanLE_country, aes(x = country, y = meanLE)) + geom_point() 

```

Simple - right!?

Once we specify the dataset we are working with we can directly type the
names of the columns and variables in the dataset we wish without have
to enclose them in quotation marks or having to define them relative to
the dataset itself.

## But there's a problem - trouble in paradise?

What happens if we want to turn the above code into a function or use it
in a loop? - Which we might want to do if we wanted to get and plot the
means of population size and gdpPercap as well as lifeExp across
continents and years. Or if want to get the means by countries/years
instead.

```{r try_function, error=TRUE}
# Place code within function

gap_means <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by(grouping_variable) %>% 
  summarise(mean = mean(summary_column, na.rm = T))
}

#Does it work?
gap_means(gapminder, year, lifeExp)

#What about if we place the arguments in quotes?
gap_means(gapminder, "year", "lifeExp")

#Another example - What if tried to build a generic plotting function for all of the above dataset?
plot_fun <- function(data, x, y){
  data %>% 
  ggplot(aes(x = x, y = y)) +
  geom_point() 
}

plot(meanLE_continent, x = continent, y = meanLE)
plot(meanLE_continent, x = "continent", y = "meanLE")

```

ALSO - a problem if you want to use dplyr functions in loops

```{r try_loop}
columns <- c("lifeExp", "pop", "gdpPercap")
out <- rep(list(NULL), 3)
out

for(i in seq_along(columns)){
  out[[i]] <- gapminder %>% 
    summarise(mean = mean(columns[[i]], na.rm = T))
}

out
```

## NSE = Non-standard evaluation (VERY VERY briefly!)

What is NSE? Very roughly, it is to programmatically modify an
expression or its meaning after it is issued but before it is executed.
You can think of an "expression" an R command you might type at the
prompt or in an R script.

*Not many programming languages give the programmer the power to
implement, use, and abuse Non-Standard Evaluation - but R does!*

And not just in Tidyverse - ALSO in base R.

```{r NSE_baseR}
subset(mtcars, hp > 250) # this works 
                         # subset delays the evalution of hp > 250 before it is run 
                         # changes its meaning/environment so it relates to mtcars 
mtcars[hp > 250, ] # Does this work?
                   # NO! hp is not defined in our environment

#Other base R NSE functions include:
transform()
lm()
with()
#and the old school (for those of us who learnt R way way before the tidyverse!):
attach()
```

Much more to learn about NSE!! See list of references at end.

#### ≈ Tidy evaluation or Tidy Eval (NSE in the Tidyverse; implemented in the rlang package) has two forms: and Tidy Selection

**Data Masking** - allows you to use data variables as if they were
variables in the environment/ objects in the workspace --\> i.e. lets
you write `my_variable` not `df$myvariable`)

-   `arrange()`, `count()`, `filter()`, `group_by()`, `mutate()`, and
    `summarise()`

Data masking makes data manipulation faster because it requires less
typing. In most (but not all) base R functions you need to refer to
variables with `$`, leading to code that repeats the name of the data
frame many times:

```{r data_masking, results = FALSE}
#Comapre Base R
gapminder[gapminder$continent == "Europe" & gapminder$pop < 1000000, ]

#With Tidyverse
gapminder %>% filter(continent == "Europe", pop < 1000000)
```

**Tidy Selection** - allows you to easily choose variables based on
their position, name, or type (e.g. `starts_with("x")` or `is.numeric`).

-   `across()`, `relocate()`, `rename()`, `select()`, and `pull()`

To determine whether a function argument uses data masking or tidy
selection, look at the documentation: in the arguments list, you'll see
`<data-masking>` or `<tidy-select>`. Let's look at a few now!

```{r}
?dplyr::arrange
```

```{r}
?dplyr::rename
```

> Tidyverse functions are built for interactivity! They make interactive
> data exploration fast and fluid (and fun!)
>
> But they add some new challenges when you attempt to use them
> indirectly such as in a for loop or a function.

## Data Masking Problems and Solutions

### **Unexpected Masking**

The key idea behind data masking is that it blurs the line between the
two different meanings of the word "variable":

-   **env-variables** are "programming" variables that live in an
    environment. They are usually created with `<-`.

-   **data-variables** are "statistical" variables that live in a data
    frame (come from data files or are created by manipulating existing
    variables).

```{r unexp_masking}

#An object in your workspace (which you want to use) has the same name as a dataset column
n <- 100
data1 <- data.frame(x = 1)
data2 <- data.frame(x = 1, n = 2)

data1 %>% mutate(y = x / n) %>% pull(y)
data2 %>% mutate(y = x / n) %>% pull(y)

```

> #### SOLUTION - Be explicit in your code

```{r unexp_mask_soln}

#Specify .data and .end pronouns
data1 %>% mutate(y = .data$x / .env$n) %>% pull(y)
data2 %>% mutate(y = .data$x / .env$n) %>% pull(y)
```

### **Indirection** 

Occurs when data-variables can't get through functions/loops

```{r indrection}
#Same function we tried to run above
gap_means <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by(grouping_variable) %>% 
  summarise(mean = mean(summary_column, na.rm = T))
}

#It doesn't work!!
gap_means(gapminder, year, lifeExp)
```

Inside the function `grouping_variable` and `summary_column` are
environment variables. But when you call the function - `year` and
`lifeExp` are data variables.

> #### SOLUTION - use the curly-curly operator '{{ }}' to Tunnel data variable through functions

```{r indrection_soln}
gap_means <- function(data, grouping_variable, summary_column){
  data %>% 
  group_by({{ grouping_variable }}) %>% 
  summarise(mean = mean({{ summary_column }}, na.rm = T))
}

#It works!!
gap_means(gapminder, year, lifeExp)
gap_means(gapminder, continent, pop)
```

### Dynamic naming of variables in functions

## The Walrus operator

`:=` is named the "Walrus operator" and is needed in some cases when
assigning values with tidy evaluation. For example, what if we wanted to
take our `group_means` function from earlier and improved it so that the
column name in the summarized data frame was the same column name as in
the original data frame?

We might then try something like this:

```{r, error=TRUE}
group_means <- function(data, grouping_column, column_to_summarize) {
  data %>% 
    group_by({{ grouping_column }}) %>% 
    summarise({{ column_to_summarize }} = mean({{ column_to_summarize }}))
}
```

But it looks like we cannot even define that function! Anytime we want
to use indirection with a column name during assignment, we need to use
the `:=` to make tidy evaluation work correctly:

```{r}
group_means <- function(data, grouping_column, column_to_summarize) {
  data %>% 
    group_by({{ grouping_column }}) %>% 
    summarise({{ column_to_summarize }} := mean({{ column_to_summarize }}))
}
```

Now we can define, and use our function!

```{r}
group_means(starwars, species, height)
```

We can even go further and combine our indirected column name with a
string to improve the column name further:

```{r}
group_means <- function(data, grouping_column, column_to_summarize) {
  data %>% 
    group_by({{ grouping_column }}) %>% 
    summarise("mean_{{ column_to_summarize }}" := mean({{ column_to_summarize }}))
}
```

```{r}
group_means(starwars, species, height)
```

### Indirection - AVOID FURTHER DATA MASKING - work with string variables as inputs to functions 

-   When you have an env-variable that is a character vector, you need
    to index into the `.data` pronoun with `[[`, like
    `summarise(df, mean = mean(.data[[var]]))`.

    The following example uses `.data` to count the number of unique
    values in each variable of `mtcars`:

    ```{r}
    group_means <- function(data, grouping_column, column_to_summarize) {
      data %>% 
        group_by(.data[[grouping_column]]) %>% 
        summarise(column_mean = mean(.data[[column_to_summarize]]))
    }
    ```

    ```{r}
    group_means(starwars, "species", "height")
    ```

    Note that `.data` is not a data frame; it's a special construct, a
    pronoun, that allows you to access the current variables either
    directly, with `.data$x` or indirectly with `.data[[var]]`. Don't
    expect other functions to work with it.

## Tidy Selection Problems and Solutions

Data masking makes it easy to compute on values within a dataset. Tidy
selection is a complementary tool that makes it easy to work with the
columns of a dataset.

### The tidyselect DSL

Underneath all functions that use tidy selection is the
[tidyselect](https://tidyselect.r-lib.org/) package. It provides a
miniature domain specific language that makes it easy to select columns
by name, position, or type. For example:

-   `select(df, 1)` selects the first column; `select(df, last_col())`
    selects the last column.

-   `select(df, c(a, b, c))` selects columns `a`, `b`, and `c`.

-   `select(df, starts_with("a"))` selects all columns whose name starts
    with "a"; `select(df, ends_with("z"))` selects all columns whose
    name ends with "z".

-   `select(df, where(is.numeric))` selects all numeric columns.

You can see more details in `?dplyr_tidy_select`.

### Indirection

As with data masking, tidy selection makes a common task easier at the
cost of making a less common task harder. When you want to use tidy
select indirectly with the column specification stored in an
intermediate variable, you'll need to learn some new tools. Again, there
are two forms of indirection:

-   When you have the data-variable in an env-variable that is a
    function argument, you use the same technique as data masking: you
    **embrace** the argument by surrounding it in doubled braces.

    The following function subsets a data frame using numerical row
    indexing and numbers or names for column indexing:

    ```{r, results = FALSE}
    rectangle <- function(data, columns, row_start, row_end) {
      data %>% 
        select({{ columns }}) %>% 
        slice(row_start:row_end)
    }
    ```

    ```{r}
    rectangle(starwars, height:eye_color, 1, 5)
    ```

-   When you have an env-variable that is a character vector, you need
    to use `all_of()` or `any_of()` depending on whether you want the
    function to error if a variable is not found.

    The following code uses `all_of()` to select all of the variables
    found in a character vector; then `!` plus `all_of()` to select all
    of the variables *not* found in a character vector:

    ```{r}
    rectangle <- function(data, columns, row_start, row_end) {
          data %>% 
            select(all_of(columns)) %>% 
            slice(row_start:row_end)
        }
    ```

    ```{r}
    vars <- c("height", "mass")
    rectangle(starwars, vars, 1, 5)
    ```

## Using tidy evaluation in other {tidyverse} package functions

Finally, we can apply this same logic to other {tidyverse} package
functions (so far we have just focused on {dplyr}), such as {ggplot2}
functions!

```{r}
scatter_plot <- function(data_frame, x_axis, y_axis) {
  ggplot(data_frame, aes(y = {{ y_axis }}, x = {{ x_axis }})) +
    geom_point(alpha = 0.5)
}
```

```{r}
scatter_plot(starwars, height, mass)
```

> If you'd like to learn more about the underlying theory, or precisely
> how it's different from non-standard evaluation, we recommend that you
> read the Metaprogramming chapters in [*Advanced
> R*](https://adv-r.hadley.nz).

So what about enquo() and !! operators and others

Do you even need to use Tidy Eval!

## References

<https://www.brodieg.com/2020/05/05/on-nse/>
